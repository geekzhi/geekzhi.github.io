{"meta":{"title":"GeekZhang's Blog","subtitle":"不乱于心，不困于情。不畏将来，不念过往。如此，安好。","description":"GeekZahng的博客","author":"John","url":"http://blog.geekzhang.com"},"pages":[{"title":"Tags","date":"2019-01-09T12:54:19.236Z","updated":"2019-01-09T12:54:19.235Z","comments":true,"path":"tags/index.html","permalink":"http://blog.geekzhang.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2016-04-20T20:48:33.000Z","updated":"2019-01-09T12:54:59.356Z","comments":true,"path":"about/index.html","permalink":"http://blog.geekzhang.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringConfig分布式配置中心","slug":"SpringConfig分布式配置中心","date":"2019-03-21T12:04:29.000Z","updated":"2019-03-21T13:24:16.095Z","comments":true,"path":"2019/03/21/SpringConfig分布式配置中心/","link":"","permalink":"http://blog.geekzhang.com/2019/03/21/SpringConfig分布式配置中心/","excerpt":"","text":"SprinngConfig配置中心入门Demo 中文文档：SpingConfig 结构如下图： 需要一个git仓库存放配置文件，还需要一个服务端，然后各个客户端去调用服务端获取具体配置。 git仓库存放的配置文件： 命名方式如下： 12345/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties 本次例子即为{application}-{profile}.yml的命名方式，“config”为客户端对应的应用名，”dev”、”test”、”pro”为对应的profile, 在配置客户端时会用到。 服务端配置：所需依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; application.yml:12345678910server: port: 8888spring: cloud: config: server: git: uri: git仓库地址 username: 自行更换 password: 自行更换 启动类添加@EnableConfigServer注解：123456789@SpringBootApplication@EnableConfigServerpublic class RemoteApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RemoteApplication.class, args); &#125;&#125; 启动后访问http://localhost:8888/config/dev 返回git仓库中的config-dev.yml配置文件内容和其他的一些信息，即说明成功，config为git仓库中配置文件的应用名，dev为配置文件的profile，同理http://localhost:8888/config/test、http://localhost:8888/config/pro 可以读取到上图中我的仓库中的其他两个文件内容：这里推荐火狐浏览器，会自动格式化json数据，看起来十分方便： 客户端接下来配置客户端所需依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 这里推荐2.0.1版本的包，用2.1.0可能会引起冲突，也和自身的springboot的版本有关，可自行更换版本。客户端需要在application.yml同级目录下，即src/main/resource下新建 bootstrap.yml 文件，配置如下：1234567spring: application: name: 对应上方git仓库的配置文件的application cloud: config: uri: http://localhost:8888 profile: 对应上方git仓库配置文件的profile 配置完后，启动项目时，便可以从远程git仓库配置文件中读取配置，然后加载启动。 引申：bootstrap.yml(或bootstrap.profile)会早于application.yml(或application.profile)加载，所以在客户端需要在bootstrap.yml中配置springconfig相关配置。 由于服务端可以直接访问获取配置文件，会造成安全问题，可搭配SpringSecurity等权限控制框架配置服务端权限，SpringConfig也提供了相应的客户端配置参数，客户端的spring.cloud.config.username和spring.cloud.config.password即为用户名和密码的配置。","categories":[],"tags":[]},{"title":"SpringCloud入门Demo","slug":"SpringCloud入门Demo","date":"2019-01-09T13:27:33.000Z","updated":"2019-01-14T14:28:37.987Z","comments":true,"path":"2019/01/09/SpringCloud入门Demo/","link":"","permalink":"http://blog.geekzhang.com/2019/01/09/SpringCloud入门Demo/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Demo\b需要建3个SpringBoot项目，一个作为Eureka注册中心，其余2个作为客户端和服务端相互调用（Springboot项目建立过程省略）,代码见：https://github.com/geekzhi/springcloud-demo Eureka\bpom.xml添加依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; \bapplication.yml配置文件：123456789101112131415server: port: 8761eureka: instance: hostname: localhost client: # 以下两项一定要是false，表明自己是服务器，而不需要从其他主机发现服务 registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://localhost:8761/eureka/ server: waitTimeInMsWhenSyncEmpty: 0 enable-self-preservation: false 启动类添加@EnableEurekaServer注解：12345678@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; server1pom.xml添加依赖：123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; \bapplication.yml配置文件：123456789101112server: port: 8080spring: application: name: server1eureka: client: service-url: defaultZone: http://localhost:8761/eureka fetch-registry: true 连接类Clients,调用server2：123456@FeignClient(\"server2\")public interface Clients &#123; @RequestMapping(\"/test\") String test();&#125; Controller:12345678910111213141516@RestControllerpublic class TestController &#123; @Autowired private Clients clients; @RequestMapping(\"/test\") public String test() &#123; return \"This is server1\"; &#125; @RequestMapping(\"/client\") public String client() &#123; return clients.test(); &#125;&#125; 启动类加注解@EnableDiscoveryClient、@EnableFeignClients：12345678910@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class Server1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Server1Application.class, args); &#125;&#125; server2与server1基本一致pom.xml添加依赖：123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; \bapplication.yml配置文件：123456789101112server: port: 8081spring: application: name: server2eureka: client: service-url: defaultZone: http://localhost:8761/eureka fetch-registry: true 连接类Clients,调用server1：123456@FeignClient(\"server1\")public interface Clients &#123; @RequestMapping(\"/test\") String test();&#125; Controller:12345678910111213141516@RestControllerpublic class TestController &#123; @Autowired private Clients clients; @RequestMapping(\"/test\") public String test() &#123; return \"This is server2\"; &#125; @RequestMapping(\"/client\") public String client() &#123; return clients.test(); &#125;&#125; 启动类加注解@EnableDiscoveryClient、@EnableFeignClients：12345678910@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class Server2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Server2Application.class, args); &#125;&#125; 先启动eureka项目，再启动server1、server2，访问http://localhost:8761可以查看eureka注册中心注册的服务情况，访问http://localhost:8080/client看到“This is server2”说明server1调用server2成功，同理，访问http://localhost:8081/client看到“This is server1”说明server2调用server1成功","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/tags/java/"}]},{"title":"Eclipse搭建springboot项目","slug":"Eclipse搭建springboot项目","date":"2018-10-14T08:57:53.000Z","updated":"2018-10-14T09:32:55.672Z","comments":true,"path":"2018/10/14/Eclipse搭建springboot项目/","link":"","permalink":"http://blog.geekzhang.com/2018/10/14/Eclipse搭建springboot项目/","excerpt":"1、按如下步骤安装sts插件","text":"1、按如下步骤安装sts插件 2、安装完插件后，新建springboot项目 项目结构：","categories":[],"tags":[]},{"title":"web开发","slug":"web开发","date":"2018-10-14T08:20:00.000Z","updated":"2018-10-15T14:10:40.639Z","comments":true,"path":"2018/10/14/web开发/","link":"","permalink":"http://blog.geekzhang.com/2018/10/14/web开发/","excerpt":"分享内容一、web开发CS，即Client/Server(客户机/服务器) BS，即Browser/Server(浏览器/服务器) BS开发发展历程：","text":"分享内容一、web开发CS，即Client/Server(客户机/服务器) BS，即Browser/Server(浏览器/服务器) BS开发发展历程： &emsp;&emsp;静态 Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的 &emsp;&emsp;ASP/JSP/PHP：ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。 &emsp;&emsp;MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。Java的SSM、SSH框架。 &emsp;&emsp;RESTful架构，EST全称是Representational State Transfer，中文意思是表述性状态转移。GET、POST、DELETE、PUT四种请求方式对应不同的功能，GET用来获取资源，POST用来创建资源，DELETE删除资源，PUT更新资源。举个例子： \b假设一个网站网址为：www.a.com, 如果我想获取用户名为“john”的用户信息，那么我请求的url应该为：“www.a.com/userInfo/john”, 请求方式为GET，对应的后端接口为“www.a.com/userInfo/{username}” 。 MVC&emsp;&emsp;MVC是一种经典的设计模式，Model-View-Controller，即模型-视图-控制器。M主要负责数据与模型，V主要负责显示，C主要负责交互与业务。如用户发送一个HTTP请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。 MVC: 改进： 额外的一些补充XML(Extensible Markup Language),可扩展标记语言,是一种标记语言，很类似 HTML,设计宗旨是传输数据，而非显示数据，标签没有被预定义，需要自行定义标签。123456&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt; JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式，对象表示为键值对、数据由逗号分隔、花括号保存对象、方括号保存数组。1234&#123; \"username\":\"john\", \"password\":\"123\"&#125; 12345678[&#123; \"username\":\"john\", \"password\":\"123\"&#125;,&#123; \"username\":\"tom\", \"password\":\"456\"&#125;] SSH框架，SSM框架 Spring，它是一个容器框架，用来装javabean（java对象），中间层框架（万能胶）可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用。简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 Struts,SpringMVC Hibernate,Mybatis &emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 二、Spring、SpringMVC、SpringBoot常用注解&emsp;&emsp;注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 &emsp;&emsp;元注解,是可以注解到注解上的注解,有 @Retention、@Documented、@Target、@Inherited、@Repeatable、@Native 6 种。 &emsp;&emsp;Java中的注解：@Override 提示子类要复写父类中被 @Override 修饰的方法 @Bean &emsp;&emsp; Bean简单的讲，就一个类。在类上加上@Bean注解，表示交给Spring去管理。 @Autowired &emsp;&emsp; 翻译：自动装配。默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。 123456789101112public class My &#123; private Test test = new Test();&#125;---------------对比----------------public class My&#123; @Autowired private Test test;&#125; @Controller &emsp;&emsp;表现层的Bean @ResponseBody &emsp;&emsp;该注解用于将Controller的方法返回的对象，通过适当的转换为指定格式后，写入到Response对象的body数据区。适用于返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； @RequestMapping &emsp;&emsp;是一个用来处理请求地址映射的注解。 &emsp;&emsp;value：指定请求的实际地址 &emsp;&emsp;method：指定请求的method类型， GET、POST、PUT、DELETE等； 123456789101112@Controllerpublic class TestController &#123; @Autowired MyService myService; @RequestMapping(value= \"/\", method = RequestMethod.GET) public void doSomething() &#123; //doSomething; &#125;&#125; @Service &emsp;&emsp;业务层的Bean 三、Maven、Mybatis、SpringBootMaven Java三大构建工具：Ant、Maven和Gradle。 Maven的主要功能主要分为5点，分别是依赖管理系统、多模块构建、一致的项目结构、一致的构建模型和插件机制。 常用命令： 123456编译：mvn compile --src/main/java目录java源码编译生成class （target目录下）测试：mvn test --src/test/java 目录编译清理：mvn clean --删除target目录，也就是将class文件等删除打包：mvn package --生成压缩文件：java项目#jar包；web项目#war包，也是放在target目录下安装：mvn install --将压缩文件(jar或者war)上传到本地仓库发布：mvn deploy --将压缩文件上传私服 资料：https://www.cnblogs.com/whgk/p/7112560.html Mybatis 参考资料：http://www.mybatis.org/mybatis-3/zh/index.html 1&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; SpringBoot &emsp;&emsp;Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. &emsp;&emsp;Spring Bug是构建基于Spring的应用程序的起点。Spring Bug的设计是为了让你尽可能快地用最小的配置启动起来你的Spring程序。","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/tags/java/"}]},{"title":"git创建分支","slug":"git创建分支","date":"2017-12-22T09:25:28.000Z","updated":"2017-12-22T09:26:59.803Z","comments":true,"path":"2017/12/22/git创建分支/","link":"","permalink":"http://blog.geekzhang.com/2017/12/22/git创建分支/","excerpt":"","text":"123git new \"name\"git checkout \"name\"git push origin \"name\"","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.geekzhang.com/tags/git/"}]},{"title":"Springboot集成Mybatis（采用XML方式）","slug":"Springboot集成Mybatis（采用XML方式）","date":"2017-12-22T03:25:57.000Z","updated":"2017-12-22T05:07:31.537Z","comments":true,"path":"2017/12/22/Springboot集成Mybatis（采用XML方式）/","link":"","permalink":"http://blog.geekzhang.com/2017/12/22/Springboot集成Mybatis（采用XML方式）/","excerpt":"Springboot集成Mybatis1.添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;","text":"Springboot集成Mybatis1.添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 2.修改配置文件（application.properties）1234567mybatis.config-locations=classpath:mybatis/mybatis-config.xmlmybatis.mapper-locations=classpath:mybatis/mapper/*.xml spring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = root 给一个mybatis-config.xml的模板 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"callSettersOnNulls\" value=\"true\"/&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias=\"Integer\" type=\"java.lang.Integer\" /&gt; &lt;typeAlias alias=\"Long\" type=\"java.lang.Long\" /&gt; &lt;typeAlias alias=\"HashMap\" type=\"java.util.HashMap\" /&gt; &lt;typeAlias alias=\"LinkedHashMap\" type=\"java.util.LinkedHashMap\" /&gt; &lt;typeAlias alias=\"ArrayList\" type=\"java.util.ArrayList\" /&gt; &lt;typeAlias alias=\"LinkedList\" type=\"java.util.LinkedList\" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 3.在启动类上加@MapperScan注解12345678@SpringBootApplication@MapperScan(\"com.kerry.mapper\")public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在每个Mapper加@Mapper注解也行，不过比较麻烦","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java mybatis","slug":"java-mybatis","permalink":"http://blog.geekzhang.com/tags/java-mybatis/"}]},{"title":"Springboot访问HTML页面","slug":"Springboot访问HTML页面","date":"2017-12-22T02:03:27.000Z","updated":"2017-12-22T05:07:51.921Z","comments":true,"path":"2017/12/22/Springboot访问HTML页面/","link":"","permalink":"http://blog.geekzhang.com/2017/12/22/Springboot访问HTML页面/","excerpt":"Springboot访问HTML页面1.导包maven:12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; gradle:compile &#39;org.springframework.boot:spring-boot-starter-thymeleaf:1.5.9.RELEASE&#39;","text":"Springboot访问HTML页面1.导包maven:12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; gradle:compile &#39;org.springframework.boot:spring-boot-starter-thymeleaf:1.5.9.RELEASE&#39; 2.修改配置文件（application.properties）spring.thymeleaf.prefix: classpath:/templates/ 然后如果你的html标签格式不标准，会报这个错误：thymeleaf Exception parsing document: template=&quot;xxxx&quot;需要再加个依赖：12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt; 以及配置文件（application.properties）：spring.thymeleaf.mode=LEGACYHTML5","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/tags/java/"}]}]}