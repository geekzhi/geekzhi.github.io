{"meta":{"title":"GeekZhang's Blog","subtitle":"不乱于心，不困于情。不畏将来，不念过往。如此，安好。","description":"GeekZahng的博客","author":"GeekZhang","url":"http://blog.geekzhang.com"},"pages":[{"title":"About","date":"2016-04-20T20:48:33.000Z","updated":"2019-01-09T12:54:59.356Z","comments":true,"path":"about/index.html","permalink":"http://blog.geekzhang.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-09T12:54:19.236Z","updated":"2019-01-09T12:54:19.235Z","comments":true,"path":"tags/index.html","permalink":"http://blog.geekzhang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ribbon负载均衡以及自定义负载均衡策略","slug":"Ribbon负载均衡以及自定义负载均衡策略","date":"2019-04-03T15:30:54.000Z","updated":"2019-04-03T16:01:39.050Z","comments":true,"path":"2019/04/03/Ribbon负载均衡以及自定义负载均衡策略/","link":"","permalink":"http://blog.geekzhang.com/2019/04/03/Ribbon负载均衡以及自定义负载均衡策略/","excerpt":"","text":"首先看下Ribbon自带的负载均衡策略： 策略名 策略声明 策略描述 实现说明 BestAvailableRule class BestAvailableRule extends ClientConfigEnabledRoundRobinRule ```|选择一个最小的并发请求的server|逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server |123456789101112|AvailabilityFilteringRule |```public class AvailabilityFilteringRule extends PredicateBasedRule```|过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）|使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态||WeightedResponseTimeRule |``` public class WeightedResponseTimeRule extends RoundRobinRule```|根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。|一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas时，使用roubine策略选择server。||RetryRule |```public class RetryRule extends AbstractLoadBalancerRule```|对选定的负载均衡策略机上重试机制。|在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server||RoundRobinRule |```public class RoundRobinRule extends AbstractLoadBalancerRule```|roundRobin方式轮询选择server|轮询index，选择index对应位置的server||RandomRule |```public class RandomRule extends AbstractLoadBalancerRule```|随机选择一个server|在index上随机，选择index对应位置的server||ZoneAvoidanceRule |```public class ZoneAvoidanceRule extends PredicateBasedRule```|复合判断server所在区域的性能和server的可用性选择server|使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。|&gt;以上表格来源：http://ju.outofmemory.cn/entry/253843除此之外，新版的Ribbon还有一些其他自带策略。首先添加Ribbon依赖：_（如果使用Feign，则自带了Ribbon包）_ org.springframework.cloud spring-cloud-starter-ribbon1创建配置类： @Configurationpublic class RibbonConfiguration { @Bean public IRule ribbonRule() { return new RoundRobinRule(); //这里采用轮询策略 }}1配置启用类： @Configuration@RibbonClient(name = “server1”, configuration = RibbonConfiguration.class)public class TestConfiguration {}1234567这里name参数为需要负载均衡的服务名，configuration参数指定配置类，这种通过java类配置较为复杂，后面会介绍通过yml配置文件配置以及对所有服务配置负载均衡的方法。到此完成负载均衡的配置，我这里调用的服务server1，如果你已经在eureka注册中心注册了两个application.name都为server1的服务，调用时Ribbon会轮询去掉用。此外，我们还可以自定义自己的负载均衡策略，此处给一个例子： public class MyTestRule extends AbstractLoadBalancerRule { private int total = 0; // 总共被调用的次数 private int currentIndex = 0; // 当前提供服务索引 public Server choose(ILoadBalancer lb, Object key) { if (lb == null) { return null; } Server server = null; while (server == null) { if (Thread.interrupted()) { return null; } List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) { return null; } if (total &lt; 3) { server = upList.get(currentIndex); total++; } else { total = 0; currentIndex++; if (currentIndex &gt;= upList.size()) { currentIndex = 0; } } if (server == null) { Thread.yield(); continue; } if (server.isAlive()) { return (server); } server = null; Thread.yield(); } return server; } @Override public Server choose(Object key) { return choose(getLoadBalancer(), key); } @Override public void initWithNiwsConfig(IClientConfig iClientConfig) { } }12345大致意思为每调用服务A三次便会调用相同的服务A2,三次后调用A3一次类推，调用到最大服务次数索引置为0再如此循环。将上述配置类的``` return new RoundRobinRule(); ```改为本类 ``` return MyTestRule ```即可实现。 由于java配置类配置较为繁琐，以下给出application.yml配置方法： server1: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #配置规则 随机 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #配置规则 重试NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重NFLoadBalancerRuleClassName: com.geekzhang.server4.configuration.MyTestRule #自定义规则，包路径自行修改12此处server1为sercer1服务的负载均衡策略，如果需要全局的负载均衡策略，只需将前缀删掉即可，如下： ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #配置规则 随机 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #配置规则 重试NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重NFLoadBalancerRuleClassName: com.geekzhang.server4.configuration.MyTestRule #自定义规则，包路径自行修改```","categories":[],"tags":[]},{"title":"SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置","slug":"SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置","date":"2019-04-02T15:39:41.000Z","updated":"2019-04-03T14:32:11.938Z","comments":true,"path":"2019/04/02/SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置/","link":"","permalink":"http://blog.geekzhang.com/2019/04/02/SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置/","excerpt":"","text":"依旧遇到了很多坑，这里记录一下。首先给一个亲测可用的pom配置，SpringBoot使用2.0.3，SpringCloud使用F版:Finchley.RELEASE。（其他版本可能会有版本不兼容等问题）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.geekzhang&lt;/groupId&gt; &lt;artifactId&gt;server1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;server1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 依赖于RabbitMq,所以需要一个RabbitMq的环境，这里推荐使用docker安装，给出安装命令：12345--获取rabbitmq镜像docker pull rabbitmq:management--启动镜像并指定用户名和密码以及映射本地端口docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management 其中RABBITMQ_DEFAULT_USER为默认用户名，这里设置为admin，RABBITMQ_DEFAULT_PASS为默认密码，这里设置为admin，15672为管理端端口，启动后访问http://localhost:15672 输入设定的用户名密码即可登录RabbitMq管理端页面。 自动刷新有两种方式，一种需要每个客户端自己去主动拉取刷新内容，第二种是Config配置中心Server端去刷新拉取并通知其他客户端去刷新配置，这里介绍第二种用法。 Server端额外引入两个依赖：123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件：123456789101112spring: rabbitmq: host: localhost port: 5672 username: admin #上方设置的RabbmitMq的默认账号 password: admin #上方设置的RabbmitMq的默认密码 management: endpoints: web: exposure: include: bus-refresh #依赖于actuator，需要配置此处 此外，如果添加了SpringSecurity需要将/actuator/**开放访问控制。 Client客户端配置和Server服务端依赖和配置文件一样，此外需要在需要动态刷新配置的类上添加@RefreshScope注解，例如：123456789101112@RestController@RefreshScopepublic class TestController &#123; @Value(\"$&#123;my.param&#125;\") String param; @RequestMapping(\"/print\") public String print() &#123; return param; &#125;&#125; 此处例子我的param变量取得是配置文件中my.param的值，需要动态刷新，所以在该类上添加@RefreshScope注解，否则不生效。 到此客户端和服务端的配置完成，启动server端和client端后，若配置文件有内容改动，采用post方式访问http://server端IP/actuator/bus-refresh 后即可实现动态刷新。 post方式访问可采用curl命令，以我的项目为例：1curl -X POST http://localhost:8888/actuator/bus-refresh 这样每次提交完配置文件都需要手动去post请求上述url才会通知各个客户端去刷新配置，依旧麻烦，这里推荐git仓库的webhook功能,以码云仓库为例： 进入项目，点击管理： 左边最下方选择WebHooks,然后点击右侧添加： 自行添加配置内容即可： 这样每次提交文件后，git仓库会自动请求我们的url，实现了自动刷新。","categories":[],"tags":[]},{"title":"Eureka添加用户认证遇到的坑","slug":"Eureka添加用户认证遇到的坑","date":"2019-03-30T08:14:04.000Z","updated":"2019-03-30T08:40:19.683Z","comments":true,"path":"2019/03/30/Eureka添加用户认证遇到的坑/","link":"","permalink":"http://blog.geekzhang.com/2019/03/30/Eureka添加用户认证遇到的坑/","excerpt":"","text":"所需依赖：SpringSecurity1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 旧版Eureak添加用户认证需要添加配置文件如下：12345678910111213141516server: port: 8761eureka: instance: hostname: localhost client: serviceUrl: defaultZone: http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eurekasecurity: basic: enabled: true user: name: username #自定义用户名 password: password #自定义密码 按照教程上配置后服务怎么也注册不到注册中心，百度之后发现2.x以后的Eureka要如下配置：2.x以后版本：123456789101112131415server: port: 8761eureka: instance: hostname: localhost client: serviceUrl: defaultZone: http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eurekaspring: security: user: name: username #自定义用户名 password: password #自定义密码 并且要禁用SpringSecurity的csrf，启动类配置如下：1234567891011121314151617@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125; @EnableWebSecurity static class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); super.configure(http); &#125; &#125;&#125; 到此完成eureka注册中心的添加用户认证功能，服务端配置如下：1234567891011121314151617server: port: 8091spring: application: name: server1eureka: client: service-url: defaultZone: http://$&#123;my.client.user-name&#125;:$&#123;my.client.password&#125;@localhost:8761/eureka fetch-registry: truemy: client: user-name: username password: password 这里为了修改方便改成${变量}替换值的写法，也可以如下写死：123456789101112server: port: 8091spring: application: name: server1eureka: client: service-url: defaultZone: http://username:password@localhost:8761/eureka fetch-registry: true 访问http://localhost:8761/eureka，提示需要输入用户名密码：输入配置的用户名密码后进入注册中心：","categories":[],"tags":[]},{"title":"SpringConfig分布式配置中心","slug":"SpringConfig分布式配置中心","date":"2019-03-21T12:04:29.000Z","updated":"2019-03-21T13:24:16.095Z","comments":true,"path":"2019/03/21/SpringConfig分布式配置中心/","link":"","permalink":"http://blog.geekzhang.com/2019/03/21/SpringConfig分布式配置中心/","excerpt":"","text":"SprinngConfig配置中心入门Demo 中文文档：SpingConfig 结构如下图： 需要一个git仓库存放配置文件，还需要一个服务端，然后各个客户端去调用服务端获取具体配置。 git仓库存放的配置文件： 命名方式如下： 12345/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties 本次例子即为{application}-{profile}.yml的命名方式，“config”为客户端对应的应用名，”dev”、”test”、”pro”为对应的profile, 在配置客户端时会用到。 服务端配置：所需依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; application.yml:12345678910server: port: 8888spring: cloud: config: server: git: uri: git仓库地址 username: 自行更换 password: 自行更换 启动类添加@EnableConfigServer注解：123456789@SpringBootApplication@EnableConfigServerpublic class RemoteApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RemoteApplication.class, args); &#125;&#125; 启动后访问http://localhost:8888/config/dev 返回git仓库中的config-dev.yml配置文件内容和其他的一些信息，即说明成功，config为git仓库中配置文件的应用名，dev为配置文件的profile，同理http://localhost:8888/config/test、http://localhost:8888/config/pro 可以读取到上图中我的仓库中的其他两个文件内容：这里推荐火狐浏览器，会自动格式化json数据，看起来十分方便： 客户端接下来配置客户端所需依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 这里推荐2.0.1版本的包，用2.1.0可能会引起冲突，也和自身的springboot的版本有关，可自行更换版本。客户端需要在application.yml同级目录下，即src/main/resource下新建 bootstrap.yml 文件，配置如下：1234567spring: application: name: 对应上方git仓库的配置文件的application cloud: config: uri: http://localhost:8888 profile: 对应上方git仓库配置文件的profile 配置完后，启动项目时，便可以从远程git仓库配置文件中读取配置，然后加载启动。 引申：bootstrap.yml(或bootstrap.profile)会早于application.yml(或application.profile)加载，所以在客户端需要在bootstrap.yml中配置springconfig相关配置。 由于服务端可以直接访问获取配置文件，会造成安全问题，可搭配SpringSecurity等权限控制框架配置服务端权限，SpringConfig也提供了相应的客户端配置参数，客户端的spring.cloud.config.username和spring.cloud.config.password即为用户名和密码的配置。","categories":[],"tags":[]},{"title":"SpringCloud入门Demo","slug":"SpringCloud入门Demo","date":"2019-01-09T13:27:33.000Z","updated":"2019-01-14T14:28:37.987Z","comments":true,"path":"2019/01/09/SpringCloud入门Demo/","link":"","permalink":"http://blog.geekzhang.com/2019/01/09/SpringCloud入门Demo/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Demo\b需要建3个SpringBoot项目，一个作为Eureka注册中心，其余2个作为客户端和服务端相互调用（Springboot项目建立过程省略）,代码见：https://github.com/geekzhi/springcloud-demo Eureka\bpom.xml添加依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; \bapplication.yml配置文件：123456789101112131415server: port: 8761eureka: instance: hostname: localhost client: # 以下两项一定要是false，表明自己是服务器，而不需要从其他主机发现服务 registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://localhost:8761/eureka/ server: waitTimeInMsWhenSyncEmpty: 0 enable-self-preservation: false 启动类添加@EnableEurekaServer注解：12345678@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; server1pom.xml添加依赖：123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; \bapplication.yml配置文件：123456789101112server: port: 8080spring: application: name: server1eureka: client: service-url: defaultZone: http://localhost:8761/eureka fetch-registry: true 连接类Clients,调用server2：123456@FeignClient(\"server2\")public interface Clients &#123; @RequestMapping(\"/test\") String test();&#125; Controller:12345678910111213141516@RestControllerpublic class TestController &#123; @Autowired private Clients clients; @RequestMapping(\"/test\") public String test() &#123; return \"This is server1\"; &#125; @RequestMapping(\"/client\") public String client() &#123; return clients.test(); &#125;&#125; 启动类加注解@EnableDiscoveryClient、@EnableFeignClients：12345678910@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class Server1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Server1Application.class, args); &#125;&#125; server2与server1基本一致pom.xml添加依赖：123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; \bapplication.yml配置文件：123456789101112server: port: 8081spring: application: name: server2eureka: client: service-url: defaultZone: http://localhost:8761/eureka fetch-registry: true 连接类Clients,调用server1：123456@FeignClient(\"server1\")public interface Clients &#123; @RequestMapping(\"/test\") String test();&#125; Controller:12345678910111213141516@RestControllerpublic class TestController &#123; @Autowired private Clients clients; @RequestMapping(\"/test\") public String test() &#123; return \"This is server2\"; &#125; @RequestMapping(\"/client\") public String client() &#123; return clients.test(); &#125;&#125; 启动类加注解@EnableDiscoveryClient、@EnableFeignClients：12345678910@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class Server2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Server2Application.class, args); &#125;&#125; 先启动eureka项目，再启动server1、server2，访问http://localhost:8761可以查看eureka注册中心注册的服务情况，访问http://localhost:8080/client看到“This is server2”说明server1调用server2成功，同理，访问http://localhost:8081/client看到“This is server1”说明server2调用server1成功","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/tags/java/"}]},{"title":"Eclipse搭建springboot项目","slug":"Eclipse搭建springboot项目","date":"2018-10-14T08:57:53.000Z","updated":"2018-10-14T09:32:55.672Z","comments":true,"path":"2018/10/14/Eclipse搭建springboot项目/","link":"","permalink":"http://blog.geekzhang.com/2018/10/14/Eclipse搭建springboot项目/","excerpt":"1、按如下步骤安装sts插件","text":"1、按如下步骤安装sts插件 2、安装完插件后，新建springboot项目 项目结构：","categories":[],"tags":[]},{"title":"web开发","slug":"web开发","date":"2018-10-14T08:20:00.000Z","updated":"2018-10-15T14:10:40.639Z","comments":true,"path":"2018/10/14/web开发/","link":"","permalink":"http://blog.geekzhang.com/2018/10/14/web开发/","excerpt":"分享内容一、web开发CS，即Client/Server(客户机/服务器) BS，即Browser/Server(浏览器/服务器) BS开发发展历程：","text":"分享内容一、web开发CS，即Client/Server(客户机/服务器) BS，即Browser/Server(浏览器/服务器) BS开发发展历程： &emsp;&emsp;静态 Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的 &emsp;&emsp;ASP/JSP/PHP：ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。 &emsp;&emsp;MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。Java的SSM、SSH框架。 &emsp;&emsp;RESTful架构，EST全称是Representational State Transfer，中文意思是表述性状态转移。GET、POST、DELETE、PUT四种请求方式对应不同的功能，GET用来获取资源，POST用来创建资源，DELETE删除资源，PUT更新资源。举个例子： \b假设一个网站网址为：www.a.com, 如果我想获取用户名为“john”的用户信息，那么我请求的url应该为：“www.a.com/userInfo/john”, 请求方式为GET，对应的后端接口为“www.a.com/userInfo/{username}” 。 MVC&emsp;&emsp;MVC是一种经典的设计模式，Model-View-Controller，即模型-视图-控制器。M主要负责数据与模型，V主要负责显示，C主要负责交互与业务。如用户发送一个HTTP请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。 MVC: 改进： 额外的一些补充XML(Extensible Markup Language),可扩展标记语言,是一种标记语言，很类似 HTML,设计宗旨是传输数据，而非显示数据，标签没有被预定义，需要自行定义标签。123456&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt; JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式，对象表示为键值对、数据由逗号分隔、花括号保存对象、方括号保存数组。1234&#123; \"username\":\"john\", \"password\":\"123\"&#125; 12345678[&#123; \"username\":\"john\", \"password\":\"123\"&#125;,&#123; \"username\":\"tom\", \"password\":\"456\"&#125;] SSH框架，SSM框架 Spring，它是一个容器框架，用来装javabean（java对象），中间层框架（万能胶）可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用。简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 Struts,SpringMVC Hibernate,Mybatis &emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 二、Spring、SpringMVC、SpringBoot常用注解&emsp;&emsp;注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 &emsp;&emsp;元注解,是可以注解到注解上的注解,有 @Retention、@Documented、@Target、@Inherited、@Repeatable、@Native 6 种。 &emsp;&emsp;Java中的注解：@Override 提示子类要复写父类中被 @Override 修饰的方法 @Bean &emsp;&emsp; Bean简单的讲，就一个类。在类上加上@Bean注解，表示交给Spring去管理。 @Autowired &emsp;&emsp; 翻译：自动装配。默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。 123456789101112public class My &#123; private Test test = new Test();&#125;---------------对比----------------public class My&#123; @Autowired private Test test;&#125; @Controller &emsp;&emsp;表现层的Bean @ResponseBody &emsp;&emsp;该注解用于将Controller的方法返回的对象，通过适当的转换为指定格式后，写入到Response对象的body数据区。适用于返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； @RequestMapping &emsp;&emsp;是一个用来处理请求地址映射的注解。 &emsp;&emsp;value：指定请求的实际地址 &emsp;&emsp;method：指定请求的method类型， GET、POST、PUT、DELETE等； 123456789101112@Controllerpublic class TestController &#123; @Autowired MyService myService; @RequestMapping(value= \"/\", method = RequestMethod.GET) public void doSomething() &#123; //doSomething; &#125;&#125; @Service &emsp;&emsp;业务层的Bean 三、Maven、Mybatis、SpringBootMaven Java三大构建工具：Ant、Maven和Gradle。 Maven的主要功能主要分为5点，分别是依赖管理系统、多模块构建、一致的项目结构、一致的构建模型和插件机制。 常用命令： 123456编译：mvn compile --src/main/java目录java源码编译生成class （target目录下）测试：mvn test --src/test/java 目录编译清理：mvn clean --删除target目录，也就是将class文件等删除打包：mvn package --生成压缩文件：java项目#jar包；web项目#war包，也是放在target目录下安装：mvn install --将压缩文件(jar或者war)上传到本地仓库发布：mvn deploy --将压缩文件上传私服 资料：https://www.cnblogs.com/whgk/p/7112560.html Mybatis 参考资料：http://www.mybatis.org/mybatis-3/zh/index.html 1&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; SpringBoot &emsp;&emsp;Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. &emsp;&emsp;Spring Bug是构建基于Spring的应用程序的起点。Spring Bug的设计是为了让你尽可能快地用最小的配置启动起来你的Spring程序。","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/tags/java/"}]},{"title":"git创建分支","slug":"git创建分支","date":"2017-12-22T09:25:28.000Z","updated":"2017-12-22T09:26:59.803Z","comments":true,"path":"2017/12/22/git创建分支/","link":"","permalink":"http://blog.geekzhang.com/2017/12/22/git创建分支/","excerpt":"","text":"123git new \"name\"git checkout \"name\"git push origin \"name\"","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.geekzhang.com/tags/git/"}]},{"title":"Springboot集成Mybatis（采用XML方式）","slug":"Springboot集成Mybatis（采用XML方式）","date":"2017-12-22T03:25:57.000Z","updated":"2017-12-22T05:07:31.537Z","comments":true,"path":"2017/12/22/Springboot集成Mybatis（采用XML方式）/","link":"","permalink":"http://blog.geekzhang.com/2017/12/22/Springboot集成Mybatis（采用XML方式）/","excerpt":"Springboot集成Mybatis1.添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;","text":"Springboot集成Mybatis1.添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 2.修改配置文件（application.properties）1234567mybatis.config-locations=classpath:mybatis/mybatis-config.xmlmybatis.mapper-locations=classpath:mybatis/mapper/*.xml spring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = root 给一个mybatis-config.xml的模板 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"callSettersOnNulls\" value=\"true\"/&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias=\"Integer\" type=\"java.lang.Integer\" /&gt; &lt;typeAlias alias=\"Long\" type=\"java.lang.Long\" /&gt; &lt;typeAlias alias=\"HashMap\" type=\"java.util.HashMap\" /&gt; &lt;typeAlias alias=\"LinkedHashMap\" type=\"java.util.LinkedHashMap\" /&gt; &lt;typeAlias alias=\"ArrayList\" type=\"java.util.ArrayList\" /&gt; &lt;typeAlias alias=\"LinkedList\" type=\"java.util.LinkedList\" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 3.在启动类上加@MapperScan注解12345678@SpringBootApplication@MapperScan(\"com.kerry.mapper\")public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在每个Mapper加@Mapper注解也行，不过比较麻烦","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java mybatis","slug":"java-mybatis","permalink":"http://blog.geekzhang.com/tags/java-mybatis/"}]},{"title":"Springboot访问HTML页面","slug":"Springboot访问HTML页面","date":"2017-12-22T02:03:27.000Z","updated":"2017-12-22T05:07:51.921Z","comments":true,"path":"2017/12/22/Springboot访问HTML页面/","link":"","permalink":"http://blog.geekzhang.com/2017/12/22/Springboot访问HTML页面/","excerpt":"Springboot访问HTML页面1.导包maven:12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; gradle:compile &#39;org.springframework.boot:spring-boot-starter-thymeleaf:1.5.9.RELEASE&#39;","text":"Springboot访问HTML页面1.导包maven:12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; gradle:compile &#39;org.springframework.boot:spring-boot-starter-thymeleaf:1.5.9.RELEASE&#39; 2.修改配置文件（application.properties）spring.thymeleaf.prefix: classpath:/templates/ 然后如果你的html标签格式不标准，会报这个错误：thymeleaf Exception parsing document: template=&quot;xxxx&quot;需要再加个依赖：12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt; 以及配置文件（application.properties）：spring.thymeleaf.mode=LEGACYHTML5","categories":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://blog.geekzhang.com/tags/java/"}]}]}