[{"title":"Ribbon负载均衡以及自定义负载均衡策略","url":"/2019/04/03/Ribbon负载均衡以及自定义负载均衡策略/","content":"\n首先看下Ribbon自带的负载均衡策略：\n\n|策略名|策略声明|策略描述|实现说明|\n|--\t|--\t|--\t|--\t|\n|BestAvailableRule|``` public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule\t```|选择一个最小的并发请求的server|逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server\t|\n|AvailabilityFilteringRule\t|```public class AvailabilityFilteringRule extends PredicateBasedRule```|过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）|使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态|\n|WeightedResponseTimeRule\t|``` public class WeightedResponseTimeRule extends RoundRobinRule```|根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。|一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas时，使用roubine策略选择server。|\n|RetryRule\t|```public class RetryRule extends AbstractLoadBalancerRule```|对选定的负载均衡策略机上重试机制。|在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server|\n|RoundRobinRule\t|```public class RoundRobinRule extends AbstractLoadBalancerRule```|roundRobin方式轮询选择server|轮询index，选择index对应位置的server|\n|RandomRule\t|```public class RandomRule extends AbstractLoadBalancerRule```|随机选择一个server|在index上随机，选择index对应位置的server|\n|ZoneAvoidanceRule\t|```public class ZoneAvoidanceRule extends PredicateBasedRule```|复合判断server所在区域的性能和server的可用性选择server|使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。|\n\n>以上表格来源：http://ju.outofmemory.cn/entry/253843\n\n除此之外，新版的Ribbon还有一些其他自带策略。\n\n首先添加Ribbon依赖：_（如果使用Feign，则自带了Ribbon包）_\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-ribbon</artifactId>\n</dependency>\n```\n创建配置类：\n```\n@Configuration\npublic class RibbonConfiguration {\n    @Bean\n    public IRule ribbonRule() {\n        return new RoundRobinRule();  //这里采用轮询策略\n    }\n}\n```\n配置启用类：\n```\n@Configuration\n@RibbonClient(name = \"server1\", configuration = RibbonConfiguration.class)\npublic class TestConfiguration {\n}\n```\n这里name参数为需要负载均衡的服务名，configuration参数指定配置类，这种通过java类配置较为复杂，后面\n会介绍通过yml配置文件配置以及对所有服务配置负载均衡的方法。\n\n到此完成负载均衡的配置，我这里调用的服务server1，如果你已经在eureka注册中心注册了两个application.name都为\nserver1的服务，调用时Ribbon会轮询去掉用。\n\n此外，我们还可以自定义自己的负载均衡策略，此处给一个例子：\n\n```\npublic class MyTestRule extends AbstractLoadBalancerRule {\n\n    private int total = 0;            // 总共被调用的次数\n    private int currentIndex = 0;    // 当前提供服务索引\n    public Server choose(ILoadBalancer lb, Object key) {\n        if (lb == null) {\n            return null;\n        }\n        Server server = null;\n        while (server == null) {\n            if (Thread.interrupted()) {\n                return null;\n            }\n            List<Server> upList = lb.getReachableServers();\n            List<Server> allList = lb.getAllServers();\n            int serverCount = allList.size();\n            if (serverCount == 0) {\n                return null;\n            }\n\n            if (total < 3) {\n                server = upList.get(currentIndex);\n                total++;\n            } else {\n                total = 0;\n                currentIndex++;\n                if (currentIndex >= upList.size()) {\n                    currentIndex = 0;\n                }\n            }\n            if (server == null) {\n                Thread.yield();\n                continue;\n            }\n            if (server.isAlive()) {\n                return (server);\n            }\n            server = null;\n            Thread.yield();\n        }\n        return server;\n    }\n\n    @Override\n    public Server choose(Object key) {\n        return choose(getLoadBalancer(), key);\n    }\n\n    @Override\n    public void initWithNiwsConfig(IClientConfig iClientConfig) {\n\n    }\n}\n```\n大致意思为每调用服务A三次便会调用相同的服务A2,三次后调用A3一次类推，调用到最大服务次数索引置为0\n再如此循环。将上述配置类的``` return new RoundRobinRule(); ```改为本类\n ``` return MyTestRule ```即可实现。\n \n由于java配置类配置较为繁琐，以下给出application.yml配置方法：\n```\nserver1:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #配置规则 随机\n#    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询\n#    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #配置规则 重试\n#    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重\n#    NFLoadBalancerRuleClassName: com.geekzhang.server4.configuration.MyTestRule #自定义规则，包路径自行修改\n\n```\n\n此处server1为sercer1服务的负载均衡策略，如果需要全局的负载均衡策略，只需将前缀删掉即可，如下：\n\n```\nribbon:\n  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #配置规则 随机\n#  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #配置规则 轮询\n#  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #配置规则 重试\n#  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #配置规则 响应时间权重\n#  NFLoadBalancerRuleClassName: com.geekzhang.server4.configuration.MyTestRule #自定义规则，包路径自行修改\n\n```\n"},{"title":"SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置","url":"/2019/04/02/SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置/","content":"依旧遇到了很多坑，这里记录一下。\n首先给一个亲测可用的pom配置，SpringBoot使用2.0.3，SpringCloud使用F版:Finchley.RELEASE。（其他版本可能会有版本不兼容等问题）\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.0.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.geekzhang</groupId>\n\t<artifactId>server1</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>server1</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>1.8</java.version>\n\t\t<spring-cloud.version>Finchley.RELEASE</spring-cloud.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-actuator</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-bus-amqp</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-openfeign</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-config</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<dependencyManagement>\n\t\t<dependencies>\n\t\t\t<dependency>\n\t\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t\t<artifactId>spring-cloud-dependencies</artifactId>\n\t\t\t\t<version>${spring-cloud.version}</version>\n\t\t\t\t<type>pom</type>\n\t\t\t\t<scope>import</scope>\n\t\t\t</dependency>\n\t\t</dependencies>\n\t</dependencyManagement>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n\t<repositories>\n\t\t<repository>\n\t\t\t<id>spring-milestones</id>\n\t\t\t<name>Spring Milestones</name>\n\t\t\t<url>https://repo.spring.io/milestone</url>\n\t\t</repository>\n\t</repositories>\n\n</project>\n\n```\n依赖于RabbitMq,所以需要一个RabbitMq的环境，这里推荐使用docker安装，给出安装命令：\n```\n--获取rabbitmq镜像\ndocker pull rabbitmq:management\n\n--启动镜像并指定用户名和密码以及映射本地端口\ndocker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management\n```\n其中RABBITMQ_DEFAULT_USER为默认用户名，这里设置为admin，RABBITMQ_DEFAULT_PASS为默认密码，这里设置为admin，15672为管理端端口，启动后访问http://localhost:15672 输入设定的用户名密码即可登录RabbitMq管理端页面。\n\n自动刷新有两种方式，一种需要每个客户端自己去主动拉取刷新内容，第二种是Config配置中心Server端去刷新拉取并通知其他客户端去刷新配置，这里介绍第二种用法。\n\nServer端额外引入两个依赖：\n```\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n\n```\n配置文件：\n```\nspring:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: admin #上方设置的RabbmitMq的默认账号\n    password: admin #上方设置的RabbmitMq的默认密码\n\t\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: bus-refresh  #依赖于actuator，需要配置此处\n```\n此外，如果添加了SpringSecurity需要将/actuator/**开放访问控制。\n\nClient客户端配置和Server服务端依赖和配置文件一样，此外需要在需要动态刷新配置的类\n上添加@RefreshScope注解，例如：\n```\n@RestController\n@RefreshScope\npublic class TestController {\n\n    @Value(\"${my.param}\")\n    String param;\n\t\n    @RequestMapping(\"/print\")\n    public String print() {\n        return param;\n    }\n}\n\n```\n此处例子我的param变量取得是配置文件中my.param的值，需要动态刷新，所以在该类上添加@RefreshScope注解，\n否则不生效。\n\n到此客户端和服务端的配置完成，启动server端和client端后，若配置文件有内容改动，采用post方式\n访问http://server端IP/actuator/bus-refresh 后即可实现动态刷新。\n\npost方式访问可采用curl命令，以我的项目为例：\n```\ncurl -X POST http://localhost:8888/actuator/bus-refresh\n```\n\n这样每次提交完配置文件都需要手动去post请求上述url才会通知各个客户端去刷新配置，依旧麻烦，这里推荐\ngit仓库的webhook功能,以码云仓库为例：\n\n进入项目，点击管理：\n![config1](SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置/config1.png)\n\n左边最下方选择WebHooks,然后点击右侧添加：\n![config2](SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置/config2.png)\n\n自行添加配置内容即可：\n![config3](SpringConfig结合SpringCloudBus以及RabbitMq实现自动刷新配置/config3.png)\n\n这样每次提交文件后，git仓库会自动请求我们的url，实现了自动刷新。\n\n"},{"title":"Eureka添加用户认证遇到的坑","url":"/2019/03/30/Eureka添加用户认证遇到的坑/","content":"所需依赖：SpringSecurity\n```\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n\n旧版Eureak添加用户认证需要添加配置文件如下：\n```\nserver:\n  port: 8761\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    serviceUrl:\n      defaultZone: http://${spring.security.user.name}:${spring.security.user.password}@${eureka.instance.hostname}:${server.port}/eureka\n\nsecurity:\n\tbasic:\n\t\tenabled: true\n\tuser:\n\t\tname: username #自定义用户名\n\t\tpassword: password #自定义密码\n```\n按照教程上配置后服务怎么也注册不到注册中心，百度之后发现2.x以后的Eureka要如下配置：\n2.x以后版本：\n```\nserver:\n  port: 8761\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    serviceUrl:\n      defaultZone: http://${spring.security.user.name}:${spring.security.user.password}@${eureka.instance.hostname}:${server.port}/eureka\n\nspring:\n  security:\n    user:\n      name: username #自定义用户名\n      password: password #自定义密码\n```\n并且要禁用SpringSecurity的csrf，启动类配置如下：\n```\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaApplication.class, args);\n\t}\n\n\t@EnableWebSecurity\n\tstatic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\t\t@Override\n\t\tprotected void configure(HttpSecurity http) throws Exception {\n\t\t\thttp.csrf().disable();\n\t\t\tsuper.configure(http);\n\t\t}\n\t}\n}\n```\n到此完成eureka注册中心的添加用户认证功能，服务端配置如下：\n```\nserver:\n  port: 8091\n\nspring:\n  application:\n    name: server1\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://${my.client.user-name}:${my.client.password}@localhost:8761/eureka\n    fetch-registry: true\n\nmy:\n  client:\n    user-name: username\n    password: password\n\n```\n这里为了修改方便改成${变量}替换值的写法，也可以如下写死：\n```\nserver:\n  port: 8091\n\nspring:\n  application:\n    name: server1\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://username:password@localhost:8761/eureka\n    fetch-registry: true\n```\n\n访问http://localhost:8761/eureka，提示需要输入用户名密码：\n![security](Eureka添加用户认证遇到的坑/security1.png)\n输入配置的用户名密码后进入注册中心：\n![security2](Eureka添加用户认证遇到的坑/security2.png)"},{"title":"SpringConfig分布式配置中心","url":"/2019/03/21/SpringConfig分布式配置中心/","content":"# SprinngConfig配置中心入门Demo\n> 中文文档：[SpingConfig](https://springcloud.cc/spring-cloud-config.html)\n\n 结构如下图：\n![原理](SpringConfig分布式配置中心/图解.png)\n\t\n 需要一个git仓库存放配置文件，还需要一个服务端，然后各个客户端去调用服务端获取具体配置。\n ## git仓库存放的配置文件：\n \n ![git](SpringConfig分布式配置中心/git.png)\n 命名方式如下：\n ```\n\t/{application}/{profile}[/{label}]\n\t/{application}-{profile}.yml\n\t/{label}/{application}-{profile}.yml\n\t/{application}-{profile}.properties\n\t/{label}/{application}-{profile}.properties\n```\n  本次例子即为{application}-{profile}.yml的命名方式，“config”为客户端对应的应用名，\"dev\"、\"test\"、\"pro\"为对应的profile,\n 在配置客户端时会用到。\n \n ## 服务端配置：\n\n所需依赖：\n```\n\t\t<dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-config-server</artifactId>\n            <version>2.1.0.RELEASE</version>\n        </dependency>\n```\napplication.yml:\n```\nserver:\n  port: 8888\nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: git仓库地址\n          username: 自行更换\n          password: 自行更换\n```\n启动类添加@EnableConfigServer注解：\n```\n@SpringBootApplication\n@EnableConfigServer\npublic class RemoteApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(RemoteApplication.class, args);\n    }\n\n}\n```\n启动后访问http://localhost:8888/config/dev 返回git仓库中的config-dev.yml配置文件内容和其他的一些信息，即说明成功，\nconfig为git仓库中配置文件的应用名，dev为配置文件的profile，同理http://localhost:8888/config/test\n、http://localhost:8888/config/pro 可以读取到上图中我的仓库中的其他两个文件内容：\n![config1](SpringConfig分布式配置中心/config1.png)\n这里推荐火狐浏览器，会自动格式化json数据，看起来十分方便：\n![config2](SpringConfig分布式配置中心/config2.png)\n\n## 客户端\n接下来配置客户端\n所需依赖：\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n    <version>2.0.1.RELEASE</version>\n</dependency>\n\n```\n这里推荐2.0.1版本的包，用2.1.0可能会引起冲突，也和自身的springboot的版本有关，可自行更换版本。\n客户端需要在application.yml同级目录下，即src/main/resource下新建 **bootstrap.yml** 文件，\n配置如下：\n```\nspring:\n  application:\n    name: 对应上方git仓库的配置文件的application\n  cloud:\n    config:\n      uri: http://localhost:8888\n      profile: 对应上方git仓库配置文件的profile\n```\n配置完后，启动项目时，便可以从远程git仓库配置文件中读取配置，然后加载启动。\n\n> 引申：bootstrap.yml(或bootstrap.profile)会早于application.yml(或application.profile)加载，所以在客户端需要在bootstrap.yml中配置springconfig相关配置。\n\n> 由于服务端可以直接访问获取配置文件，会造成安全问题，可搭配SpringSecurity等权限控制框架配置服务端权限，SpringConfig也提供了相应的客户端配置参数，客户端的spring.cloud.config.username和spring.cloud.config.password即为用户名和密码的配置。"},{"title":"SpringCloud入门Demo","url":"/2019/01/09/SpringCloud入门Demo/","content":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Demo\b需要建3个SpringBoot项目，一个作为Eureka注册中心，其余2个作为客户端和服务端相互调用（Springboot项目建立过程省略）,代码见：<https://github.com/geekzhi/springcloud-demo>*\n\n## Eureka\n\bpom.xml添加依赖：\n```\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\bapplication.yml配置文件：\n```\nserver:\n  port: 8761\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    # 以下两项一定要是false，表明自己是服务器，而不需要从其他主机发现服务\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n  server:\n    waitTimeInMsWhenSyncEmpty: 0\n    enable-self-preservation: false\n```\n启动类添加@EnableEurekaServer注解：\n```\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaApplication {\n\n\tpublic static void main(String[] args) {\n\t    SpringApplication.run(EurekaApplication.class, args);\n\t}\n}\n```\n\n## server1\npom.xml添加依赖：\n```\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-feign</artifactId>\n\t<version>1.4.4.RELEASE</version>\n</dependency>\n\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-test</artifactId>\n\t<scope>test</scope>\n</dependency>\n```\n\bapplication.yml配置文件：\n```\nserver:\n  port: 8080\n\nspring:\n  application:\n    name: server1\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka\n    fetch-registry: true\n```\n连接类Clients,调用server2：\n```\n@FeignClient(\"server2\")\npublic interface Clients {\n\n    @RequestMapping(\"/test\")\n    String test();\n}\n```\n\nController:\n```\n@RestController\npublic class TestController {\n\n    @Autowired\n    private Clients clients;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        return \"This is server1\";\n    }\n\n    @RequestMapping(\"/client\")\n    public String client() {\n        return clients.test();\n    }\n}\n\n```\n\n启动类加注解@EnableDiscoveryClient、@EnableFeignClients：\n```\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class Server1Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Server1Application.class, args);\n\t}\n\n}\n```\n\n## server2 \n### 与server1基本一致\npom.xml添加依赖：\n```\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-feign</artifactId>\n\t<version>1.4.4.RELEASE</version>\n</dependency>\n\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-test</artifactId>\n\t<scope>test</scope>\n</dependency>\n```\n\bapplication.yml配置文件：\n```\nserver:\n  port: 8081\n\nspring:\n  application:\n    name: server2\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka\n    fetch-registry: true\n```\n连接类Clients,调用server1：\n```\n@FeignClient(\"server1\")\npublic interface Clients {\n\n    @RequestMapping(\"/test\")\n    String test();\n}\n```\n\nController:\n```\n@RestController\npublic class TestController {\n\n    @Autowired\n    private Clients clients;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        return \"This is server2\";\n    }\n\n    @RequestMapping(\"/client\")\n    public String client() {\n        return clients.test();\n    }\n}\n\n```\n\n启动类加注解@EnableDiscoveryClient、@EnableFeignClients：\n```\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class Server2Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Server2Application.class, args);\n\t}\n\n}\n```\n\n先启动eureka项目，再启动server1、server2，访问<http://localhost:8761>可以查看eureka注册中心注册的服务情况，访问<http://localhost:8080/client>看到“This is server2\"说明server1调用server2成功，同理，访问<http://localhost:8081/client>看到“This is server1\"说明server2调用server1成功","tags":["java"],"categories":["java"]},{"title":"Eclipse搭建springboot项目","url":"/2018/10/14/Eclipse搭建springboot项目/","content":"\n## 1、按如下步骤安装sts插件\n\n<!--more-->\n![](Eclipse搭建springboot项目/1.png)\n\n![](Eclipse搭建springboot项目/2.png)\n\n![](Eclipse搭建springboot项目/3.png)\n\n![](Eclipse搭建springboot项目/4.png)\n\n![](Eclipse搭建springboot项目/5.png)\n\n![](Eclipse搭建springboot项目/6.png)\n\n![](Eclipse搭建springboot项目/7.png)\n\n## 2、安装完插件后，新建springboot项目\n\n![](Eclipse搭建springboot项目/8.png)\n\n![](Eclipse搭建springboot项目/9.png)\n\n![](Eclipse搭建springboot项目/10.png)\n\n![](Eclipse搭建springboot项目/11.png)\n\n### 项目结构：\n\n![](Eclipse搭建springboot项目/12.png)"},{"title":"web开发","url":"/2018/10/14/web开发/","content":"# 分享内容\n## **一、web开发**\nCS，即Client/Server(客户机/服务器)\n\nBS，即Browser/Server(浏览器/服务器)\n\n### **BS开发发展历程：**\n<!--more-->\n&emsp;&emsp;静态 Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的 \n\n\n&emsp;&emsp;ASP/JSP/PHP：ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。\n\n&emsp;&emsp;MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。Java的SSM、SSH框架。\n\n&emsp;&emsp;RESTful架构，EST全称是Representational State Transfer，中文意思是表述性状态转移。GET、POST、DELETE、PUT四种请求方式对应不同的功能，GET用来获取资源，POST用来创建资源，DELETE删除资源，PUT更新资源。举个例子： \b假设一个网站网址为：www.a.com, 如果我想获取用户名为“john”的用户信息，那么我请求的url应该为：“www.a.com/userInfo/john”, 请求方式为GET，对应的后端接口为“www.a.com/userInfo/{username}” 。\n\n### **MVC**\n\n&emsp;&emsp;MVC是一种经典的设计模式，Model-View-Controller，即模型-视图-控制器。M主要负责数据与模型，V主要负责显示，C主要负责交互与业务。\n如用户发送一个HTTP请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。\n\n![1.png](web开发/1.png)\n\nMVC:\n\n![mvc原版](web开发/mvc原版.png)\n\n改进：\n\n![mvc改进](web开发/MVC改进.png)\n### 额外的一些补充\n\n**XML**(Extensible Markup Language),可扩展标记语言,是一种标记语言，很类似 HTML,设计宗旨是传输数据，而非显示数据，标签没有被预定义，需要自行定义标签。\n```\n<note>\n    <to>George</to>\n    <from>John</from>\n    <heading>Reminder</heading>\n    <body>Don't forget the meeting!</body>\n</note>\n```\n\n**JSON**(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式，对象表示为键值对、数据由逗号分隔、花括号保存对象、方括号保存数组。\n```\n    {\n        \"username\":\"john\",\n        \"password\":\"123\"\n    }\n```\n\n```\n     [{\n        \"username\":\"john\",\n        \"password\":\"123\"\n     },\n     {\n         \"username\":\"tom\",\n         \"password\":\"456\"\n     }]\n```\n**SSH框架，SSM框架** \n\nSpring，它是一个容器框架，用来装javabean（java对象），中间层框架（万能胶）可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用。简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。\n\nStruts,SpringMVC\n\nHibernate,Mybatis\n\n&emsp;&emsp;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n\n## **二、Spring、SpringMVC、SpringBoot常用注解**\n\n&emsp;&emsp;注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。\n\n&emsp;&emsp;元注解,是可以注解到注解上的注解,有 @Retention、@Documented、@Target、@Inherited、@Repeatable、@Native 6 种。\n\n&emsp;&emsp;Java中的注解：@Override 提示子类要复写父类中被 @Override 修饰的方法\n\n![注解](web开发/注解.png)\n\n**@Bean**\n\n&emsp;&emsp; Bean简单的讲，就一个类。在类上加上@Bean注解，表示交给Spring去管理。\n\n**@Autowired**\n\n&emsp;&emsp; 翻译：自动装配。默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。\n\n```\npublic class My {\n    private Test test = new Test();\n}\n\n---------------对比----------------\n\npublic class My{\n\n    @Autowired\n    private Test test;\n\n}   \n```\n\n**@Controller**\n\n&emsp;&emsp;表现层的Bean\n\n**@ResponseBody**\n\n&emsp;&emsp;该注解用于将Controller的方法返回的对象，通过适当的转换为指定格式后，写入到Response对象的body数据区。适用于返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\n\n**@RequestMapping**\n\n&emsp;&emsp;是一个用来处理请求地址映射的注解。\n\n&emsp;&emsp;value：指定请求的实际地址\n\n&emsp;&emsp;method：指定请求的method类型， GET、POST、PUT、DELETE等；\n\n```\n@Controller\npublic class TestController {\n\t\n\t@Autowired\n\tMyService myService;\n\t\n\t@RequestMapping(value= \"/\", method = RequestMethod.GET)\n\tpublic void  doSomething() {\n\t\t//doSomething;\n\t}\n\n}\n```\n\n**@Service**\n\n&emsp;&emsp;业务层的Bean\n\n## **三、Maven、Mybatis、SpringBoot**\n\n**Maven**\n\nJava三大构建工具：Ant、Maven和Gradle。\n\nMaven的主要功能主要分为5点，分别是依赖管理系统、多模块构建、一致的项目结构、一致的构建模型和插件机制。\n\n常用命令：\n\n```\n编译：mvn compile　 　 --src/main/java目录java源码编译生成class （target目录下）\n测试：mvn test　　　   --src/test/java 目录编译\n清理：mvn clean　　　  --删除target目录，也就是将class文件等删除\n打包：mvn package　   --生成压缩文件：java项目#jar包；web项目#war包，也是放在target目录下\n安装：mvn install　　  --将压缩文件(jar或者war)上传到本地仓库\n发布：mvn deploy      --将压缩文件上传私服\n```\n\n资料：https://www.cnblogs.com/whgk/p/7112560.html\n\n\n**Mybatis**\n\n参考资料：\nhttp://www.mybatis.org/mybatis-3/zh/index.html\n\n```\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n```\n**SpringBoot**\n\n>&emsp;&emsp;Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.\n\n>&emsp;&emsp;Spring Bug是构建基于Spring的应用程序的起点。Spring Bug的设计是为了让你尽可能快地用最小的配置启动起来你的Spring程序。","tags":["java"],"categories":["java"]},{"title":"git创建分支","url":"/2017/12/22/git创建分支/","content":"```bash\n\tgit new \"name\"\n\tgit checkout \"name\"\n\tgit push origin \"name\"\n```\n\n","tags":["git"]},{"title":"Springboot集成Mybatis（采用XML方式）","url":"/2017/12/22/Springboot集成Mybatis（采用XML方式）/","content":"# Springboot集成Mybatis\n## 1.添加依赖\n```xml\n<dependency> \n\t<groupId>org.mybatis.spring.boot</groupId>\n\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t<version>1.1.1</version>\n</dependency>\n```\n<!--more-->\n## 2.修改配置文件（application.properties）\n```\n\tmybatis.config-locations=classpath:mybatis/mybatis-config.xml\n\tmybatis.mapper-locations=classpath:mybatis/mapper/*.xml \n\t\n\tspring.datasource.driverClassName = com.mysql.jdbc.Driver\n\tspring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf-8\n\tspring.datasource.username = root\n\tspring.datasource.password = root\n```\n 给一个mybatis-config.xml的模板\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n\t<settings>\n\t\t<setting name=\"callSettersOnNulls\" value=\"true\"/>\n\t\t\n\t\t<setting name=\"cacheEnabled\" value=\"true\"/>\n\t\t\n\t\t<setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n\t\t\n\t\t<setting name=\"aggressiveLazyLoading\" value=\"true\"/>\n\t\t\n\t\t<setting name=\"multipleResultSetsEnabled\" value=\"true\"/>\n\t\t\n\t\t<setting name=\"useColumnLabel\" value=\"true\"/>\n\t\t\n\t\t<setting name=\"useGeneratedKeys\" value=\"false\"/>\n\t\t\n\t\t<setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/>\n\t\t\n\t\t<setting name=\"defaultExecutorType\" value=\"SIMPLE\"/>\n\t\t\n\t\t<setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n\t\t\n        <setting name=\"localCacheScope\" value=\"SESSION\"/>\n\t\t\n        <setting name=\"jdbcTypeForNull\" value=\"NULL\"/>\n\t\t\n\t</settings>\n\n\t<typeAliases>\n\t\t<typeAlias alias=\"Integer\" type=\"java.lang.Integer\" />\n\t\t<typeAlias alias=\"Long\" type=\"java.lang.Long\" />\n\t\t<typeAlias alias=\"HashMap\" type=\"java.util.HashMap\" />\n\t\t<typeAlias alias=\"LinkedHashMap\" type=\"java.util.LinkedHashMap\" />\n\t\t<typeAlias alias=\"ArrayList\" type=\"java.util.ArrayList\" />\n\t\t<typeAlias alias=\"LinkedList\" type=\"java.util.LinkedList\" />\n\t</typeAliases>\n</configuration>\n```\n# 3.在启动类上加@MapperScan注解\n```java\n@SpringBootApplication\n@MapperScan(\"com.kerry.mapper\")\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n}\n```\n在每个Mapper加@Mapper注解也行，不过比较麻烦\n\n","tags":["java mybatis"],"categories":["java"]},{"title":"Springboot访问HTML页面","url":"/2017/12/22/Springboot访问HTML页面/","content":"# Springboot访问HTML页面\n## 1.导包\nmaven:\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-thymeleaf</artifactId>\n  <version>1.5.9.RELEASE</version>\n</dependency>\n```\ngradle:\n`compile 'org.springframework.boot:spring-boot-starter-thymeleaf:1.5.9.RELEASE'`\n<!--more-->\n## 2.修改配置文件（application.properties）\n`spring.thymeleaf.prefix: classpath:/templates/`\n\n**然后如果你的html标签格式不标准，会报这个错误：**\n`thymeleaf Exception parsing document: template=\"xxxx\"`\n需要再加个依赖：\n```xml\n<dependency>\n    <groupId>net.sourceforge.nekohtml</groupId>\n    <artifactId>nekohtml</artifactId>\n    <version>1.9.22</version>\n</dependency>\n```\n以及配置文件（application.properties）：\n`spring.thymeleaf.mode=LEGACYHTML5`\n\n\n\n\n\n","tags":["java"],"categories":["java"]}]